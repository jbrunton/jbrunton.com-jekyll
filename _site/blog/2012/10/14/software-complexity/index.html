<!DOCTYPE html>
<html>
    <head>
        <title>Avoid Incidental Complexity - jbrunton.com</title>
        <link href="/public/css/site.css" rel="stylesheet" type="text/css" />
        <link href="/public/css/pygments.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div class="header">
            <div class="wrapper">
                <div class="content">
                    <nav>
                        <a id="home" href="/">
                            <h3>jbrunton.com</h3>
                        </a>
                        <ul>
                        
                            <li>
                            
                                <a href="/software-design.html">Software Design</a>
                            
                            </li>
                        
                            <li>
                            
                                <a href="/software-testability.html">Testability</a>
                            
                            </li>
                        
                            <li>
                            
                                <a href="/programming-languages.html">Programming Languages</a>
                            
                            </li>
                        
                        </ul>
                    </nav>
                </div>
            </div>
        </div>
        <div class="wrapper">
            <div class="box">
                <div class="content">
                    <div class="clearfix">
    <div class="two columns">
        <h1>Avoid Incidental Complexity</h1>

        <p>Posted 14 Oct 2012</p>

        <p class="tags">Tags:
            
            
    <span class="tag"><a href="/blog/tag/Software%20Design">Software Design</a></span>

    <span class="tag"><a href="/blog/tag/Software%20Complexity">Software Complexity</a></span>

    <span class="tag"><a href="/blog/tag/Incidental%20Complexity">Incidental Complexity</a></span>




        </p>

        <p>It's a well understood precept that well written software should avoid unnecessary complexity - but formally defining the kinds of complexity we seek to avoid is difficult. How, then, should we set about identifying code which is overly complex; and how can we improve it?</p>

<h2>Defining Complexity</h2>

<p>There are plenty of definitions for complexity to choose from.  Here's one which seems intuitive:</p>

<blockquote><p>Complexity in software is perceived as the number of interacting elements within a software system, the internal structure of these elements, and the number and nature of interdependencies among them</p>

<p><cite>R. Taylor, N. Medvidovic and E. Dashofy,  <em>Software Architecture: Foundations, Theory and Practice</em>, Hoboken, NJ: John Wiley &amp; Sons, 2009.</cite></p></blockquote>

<p>...</p>

<p>There are also metrics available to help us measure the complexity of our programs.</p>

<p>...</p>

<p>But how useful are these definitions in practice?  Is it really useful to put a figure on the complexity of your application?  It's probably clear that your multi-platform web service (complete with mobile apps) has a high degree of complexity than the rake task which deploys it - but how does that help you structure it better?  What's needed instead are some rules of thumb to help us identify code which we should simplify to achieve greater clarity or robustness.</p>

<h2>Incidental Complexity</h2>

<p>Here's another way we can categorize complexity - by making the distinction between incidental (or accidental) and inherent (or essential) complexity:</p>

<blockquote><p>Accidental complexity: Relates to difficulties a programmer faces due to the chosen software engineering tools. A better fitting set of tools or a more high-level programming language may reduce it.</p>

<p>Essential complexity: Is caused by the characteristics of the problem to be solved and cannot be reduced.</p></blockquote>

<p><cite>Wikipedia</cite></p>

<p>In my opinion, this isn't general enough.  Plenty of code features incidental complexity (i.e. that which is not inherent to solving the problem at hand) due to the way it's been written.  Consider this example:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">selectedItems</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">k</span><span class="p">].</span><span class="nx">selected</span><span class="p">())</span> <span class="p">{</span>
            <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>




<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">predicate</span><span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">k</span><span class="p">]))</span> <span class="p">{</span>
            <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">selectedItems</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">selected</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre>
</div>


<p>In a blog post, Peter Rosser describes a related kind of complexity:</p>

<blockquote><p>System complexity is a property of a system that is directly proportional to the difficulty one has in comprehending the system at the level and detail necessary to make changes to the system without introducing instability or functional regressions.</p>

<p><cite><a href="http://blogs.msdn.com/b/peterrosser/archive/2006/06/02/softwarecomplexity.aspx">Peter Rosser</a></cite></p></blockquote>

<p>Here we're getting somewhere.  What's most critical to having a system which one can reason about, develop and maintain is to avoid local complexity.  If you can safely make local modifications, then it matters less how complex the whole application is - you don't need to understand it all at once to develop.</p>

<p>I prefer a more succinct, definition, however:</p>

<blockquote><p>Incidental complexity is anything which distracts from solving <em>the problem at hand</em>.</p></blockquote>

<p>I prefer this formulation because it highlights (even without the emphasis) the multiplicity we should be concerned with: at any one point in our code, we should be solving for one problem.  One of the most</p>

<p>incidental complexity:
- incorrect choice of algorithm/solution/data structure
- complexity incidental to solution of problem (i.e. solving multiple problems simultaneously)
- too abstract</p>

<p>so Simplest def: that which distracts from the problem at hand.  Thus both solving multiple problems, and solving with extra abstraction (introducing extra levels of indirection), are incidental. (Also consider abstraction in terms of problems with eg visitor)</p>

<p>avoid incidental complexity, and the others will follow?</p>

<h2>- solving problems individually => much easier to avoid complex branching after decomposing problem (so reduces cyclomatic complexity of individual functions)</h2>

<ul>
<li>intro - what is complexity, and why avoid it?  intuitively, ....</li>
<li>various formalizations</li>
<li>incidental vs accidental (and definitions)</li>
</ul>



        
            <h3>Related Posts:</h3>
            
            <ul class="posts">

    <li><span id="date">16 Oct 2012</span> &raquo; <a href="/blog/2012/10/16/dependency-injection">Why Dependency Injection Matters In Dynamic Languages</a></li>

    <li><span id="date">15 Oct 2012</span> &raquo; <a href="/blog/2012/10/15/principles-of-good-software-design">Principles of Good Software Design</a></li>

    <li><span id="date">12 Oct 2012</span> &raquo; <a href="/blog/2012/10/12/how-to-write-testable-code">How To Write Testable Code</a></li>

</ul>



        
    </div>
</div>

                </div>
            </div>
        </div>
        <footer class="wrapper">
            <p>I work as a full-stack web and systems engineer across a variety of technologies (including JavaScript/CoffeeScript, Ruby on Rails and <a class="link" target="_blank" href="http://en.wikipedia.org/wiki/Tcl">something called TcL</a>).
            <p>My background includes .NET/WPF application development with Prism, and I have experience with a number of functional languages (including Haskell and OCaml).  One of the subjects I therefore find interesting is how, with modern languages, the best practices from these different technology stacks and paradigms can be combined to create a best of all worlds.
            <p>I'm also interested in the theory of software design, and I'm always striving to find ways to make it intuitive and to easily put it into practice.  As such, a lot of content on this site will endeavor to distil the theory down to easily applicable principles.
            <p>Site developed and designed by me:
                <a class="link" target="_blank" href="https://twitter.com/JohnBrunton">@johnbrunton</a>
        </footer>
    </body>
</html>
