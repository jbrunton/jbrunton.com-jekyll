<!DOCTYPE html>
<html>
    <head>
        <title>Principles of Software Design - jbrunton.com</title>
        <link href="/public/css/site.css" rel="stylesheet" type="text/css" />
        <link href="/public/css/pygments.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div class="header">
            <div class="wrapper">
                <div class="content">
                    <nav>
                        <a id="home" href="/">
                            <h3>jbrunton.com</h3>
                        </a>
                        <ul>
                        
                            <li>
                            
                                <a href="/software-design.html">Software Design</a>
                            
                            </li>
                        
                            <li>
                            
                                <a href="/software-testability.html">Software Testability</a>
                            
                            </li>
                        
                            <li>
                            
                                <a href="/programming-languages.html">Programming Languages</a>
                            
                            </li>
                        
                        </ul>
                    </nav>
                </div>
            </div>
        </div>
        <div class="wrapper">
            <div class="box">
                <div class="content">
                    <h1>Principles of Software Design</h1>

<p>Over the years I've tried to distil the ideas I've had which, in my opinion, underpin all good software design.  Irrespective of the language, framework or codebase you're working across, well designed code should always respect these principles:</p>

<ol>
<li><p>Each unit of code should solve one problem at a time.  (This can also be phrased as: avoid incidental complexity in application code in order to focus on solving the inherent complexity of the problem to hand.)</p></li>
<li><p>Each problem should be solved only once.  (In other words: the <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a> principle.)</p></li>
<li><p>Code without tests is already broken.</p></li>
</ol>


<h2>Divide &amp; Conquer</h2>

<p>The last two of these principles (write DRY code and write tests) have been well understood by the software community for a long time.  The first is a little more subtle, and I'm not aware of a catchy name for the principle, so I'll refer to it colloquially as "divide and conquer".</p>

<p>In effect, what it says is that clear, maintainable software should avoid polluting a unit of code with "noise" - all the code should be concerned with solving the problem at hand, rather than the incidental quirks of the particular implementation.</p>

<p>Why?
- likely to be reused in future - and more likely to be reusable if a general interface is defined (e.g. having a filter function, as opposed to iteration and boolean check)
- likely to be more testable - by factoring out such code, you can test it in isolation (and this provide better code coverage which will flag problems more directly)
- clarity - break down the problem into individual components and solve them individually</p>

<p>For example, consider this JavaScript function:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">selectedItems</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">k</span><span class="p">].</span><span class="nx">selected</span><span class="p">())</span> <span class="p">{</span>
            <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>


<p>The problem the function is solving for is to filter a list to exclude items for which <code>selected()</code> evaluates to false.  (It should be fairly clear where this example is going, but bear with me while I emphasize the key motivations for refactoring here.)</p>

<p>The problem with the implementation of this function is that there's plenty of <em>incidental complexity</em> to it: the <code>results</code> variable, the iteration loop and variable and the building of the array are all incidental to the way in which we build the filtered list, and not inherent to the problem of specifying a way to filter.  Thus our code suffers from two problems:</p>

<ol>
<li><p>The signal-to-noise ratio is high: our code is far from being as concise as it could be, because of the incidental complexity.</p></li>
<li><p>Filtering is a pretty useful operation: if we factor it out, we can test the code in isolation, and make the function available for reuse in the future.</p></li>
</ol>


<p>Thus, we end up with two functions, both of which are solving a single problem:</p>

<div class="highlight"><pre><code class="javascript"><span class="kd">function</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="nx">predicate</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">results</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">predicate</span><span class="p">(</span><span class="nx">items</span><span class="p">[</span><span class="nx">k</span><span class="p">]))</span> <span class="p">{</span>
            <span class="nx">results</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">results</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">selectedItems</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">items</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">item</span><span class="p">.</span><span class="nx">selected</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre>
</div>


<p>The benefits are then:</p>

<ul>
<li>We can reuse <code>filter</code> across other units of code.</li>
<li>Our implementation of <code>selectedItems</code> is clearer (as will be any other client sites of <code>filter</code>).</li>
<li>We can test the two functions in isolation - and thus it will be easier to identify the nature of any test failures.</li>
</ul>


<h2>A Corollary: Design Patterns</h2>

<p>In light of this, it's interesting to note that use of design patterns sometimes introduces undesirable, incidental complexity to a codebase.  Sometimes this may be unavailable, and may be a reflection of the limits of the language being used.  But frequently it should be possible to make the use of design patterns more transparent by hiding them below more readable interfaces.</p>

<p>We can at this point pause to consider an important differentiator between design patterns: whether or not they are introducing incidental complexity to a problem, because they are addressing the limits of the underlying language (e.g. the visitor pattern, acting as a poor man's multiple-dispatch - which is never needed in a language with pattern matching).  Contrast this with the MVC pattern, which serves as a pattern to structure an application in a logical, loosely coupled manner, and you can see these two patterns are in fact performing very different functions.</p>

                </div>
            </div>
        </div>
        <footer class="wrapper">
            <p>I work as a full-stack web and systems engineer across a variety of technologies (including JavaScript/CoffeeScript, Ruby on Rails and <a class="link" target="_blank" href="http://en.wikipedia.org/wiki/Tcl">something called TcL</a>).
            <p>My background includes .NET/WPF application development with Prism, and I have experience with a number of functional languages (including Haskell and OCaml).  One of the subjects I therefore find interesting is how, with modern languages, the best practices from these different technology stacks and paradigms can be combined to create a <a class="link" href="/blog/2012/10/21/introducing-frappuccino">best of all worlds</a>.
            <p>I'm also interested in the theory of software design, and I'm always striving to find ways to make it intuitive and to easily put it into practice.  As such, a lot of content on this site will endeavor to distil the theory down to easily applicable principles.
            <p>Site developed and designed by me:
                <a class="link" target="_blank" href="https://twitter.com/JohnBrunton">@johnbrunton</a>
        </footer>
    </body>
</html>
