<!DOCTYPE html>
<html>
    <head>
        <title>jbrunton.com</title>
        <link href="/public/css/site.css" rel="stylesheet" type="text/css" />
        <link href="/public/css/pygments.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <div class="header">
            <div class="wrapper">
                <div class="content">
                    <nav>
                        <a id="home" href="/">
                            <h3>jbrunton.com</h3>
                        </a>
                        
                            
                                <a href="/religion.html">Religion</a>
                            
                        
                            
                                <a href="/software.html">Software</a>
                            
                        
                            
                                <a href="/about.html">About Me</a>
                            
                        
                    </nav>
                </div>
            </div>
        </div>
        <div class="wrapper">
            <div class="box">
                <div class="content">
                    <h1>Principles of Good Software Design</h1>

<p class="tags"> Tags:
    
    
    <span class="tag"><a href="/tag/Software%20Design">Software Design</a></span>

    <span class="tag"><a href="/tag/Software%20Complexity">Software Complexity</a></span>

    <span class="tag"><a href="/tag/Incidental%20Complexity">Incidental Complexity</a></span>




</p>

<p>It's a well understood precept that well written software should avoid unnecessary complexity - but formally defining the kinds of complexity we seek to avoid is difficult, so how should we set about recognizing code which is in need of simplification?</p>

<h2>(Trying) To Define Complexity</h2>

<p>There are plenty of definitions for complexity to choose from.  A quick Google reveals quite a number:</p>

<p>...formal definitions...</p>

<p>But how useful are these definitions?</p>

<h2>Incidental Complexity</h2>

<p>There's another way we can categorize complexity, however.  Wikipedia also highlights the distinction between incidental (or accidental) and inherent (or essential) complexity:</p>

<blockquote><p>Accidental complexity: Relates to difficulties a programmer faces due to the chosen software engineering tools. A better fitting set of tools or a more high-level programming language may reduce it.
Essential complexity: Is caused by the characteristics of the problem to be solved and cannot be reduced.</p></blockquote>

<p>In my opinion, this isn't general enough.  Plenty of code features incidental complexity - i.e. that which is not inherent to solving the problem at hand.</p>

<p>In a blog post, Peter Rosser describes a related kind of complexity:</p>

<blockquote><p>System complexity is a property of a system that is directly proportional to the difficulty one has in comprehending the system at the level and detail necessary to make changes to the system without introducing instability or functional regressions.</p>

<p><cite><a href="http://blogs.msdn.com/b/peterrosser/archive/2006/06/02/softwarecomplexity.aspx">Peter Rosser</a></cite></p></blockquote>

<p>Here we're getting somewhere.  What's most critical to having a system which one can reason about, develop and maintain is to avoid local complexity.  If you can safely make local modifications, then it matters less how complex the whole application is - you don't need to understand it all at once to develop.</p>

<p>I prefer a more succinct, definition, however:</p>

<blockquote><p>Incidental complexity is anything which distracts from solving <em>the problem at hand</em>.</p></blockquote>

<p>I prefer this formulation because it highlights (even without the emphasis) the multiplicity we should be concerned with: at any one point in our code, we should be solving for one problem.  One of the most</p>

<p>incidental complexity:
- incorrect choice of algorithm/solution/data structure
- complexity incidental to solution of problem (i.e. solving multiple problems simultaneously)
- too abstract</p>

<p>so Simplest def: that which distracts from the problem at hand.  Thus both solving multiple problems, and solving with extra abstraction (introducing extra levels of indirection), are incidental. (Also consider abstraction in terms of problems with eg visitor)</p>

<p>avoid incidental complexity, and the others will follow?</p>

<h2>- solving problems individually => much easier to avoid complex branching after decomposing problem (so reduces cyclomatic complexity of individual functions)</h2>

<ul>
<li>intro - what is complexity, and why avoid it?  intuitively, ....</li>
<li>various formalizations</li>
<li>incidental vs accidental (and definitions)</li>
</ul>



<div id="related-posts">
    <h3>Related Posts</h3>
    
    <ul class="posts">

    <li><span id="date">16 Oct 2012</span> &raquo; <a href="/2012/10/16/dependency-injection">Dependency Injection</a></li>

    <li><span id="date">15 Oct 2012</span> &raquo; <a href="/2012/10/15/principles-of-good-software-design">Principles of Good Software Design</a></li>

</ul>



</div>

                </div>
            </div>
        </div>
        <footer>
            <p>Developed and designed by me.
                <a class="link" target="_blank" href="https://twitter.com/JohnBrunton">@johnbrunton</a></p>
        </footer>
    </body>
</html>
